use crate::Xoofff;
use std::fs::File;
use std::io::{BufRead, BufReader};

/// Test functional correctness of Xoofff deck function, by using
/// known answer tests, generated by following steps described on
/// https://gist.github.com/itzmeanjan/504113021dec30a0909e5f5b47a5bde5
#[test]
fn test_xoofff_kat() {
    let kat_file = "./kats/Xoofff_KAT_no_offset.txt";
    let file = File::open(kat_file).unwrap();
    let mut reader = BufReader::new(file).lines();

    while let Some(line) = reader.next() {
        // key to be used for instantiating deck function
        let key = line.unwrap();
        let key = key.split(" ").collect::<Vec<_>>()[1];
        let key = hex::decode(key).unwrap();

        // message to be absorbed into deck function
        let msg = reader.next().unwrap().unwrap();
        let msg = msg.split(" ").collect::<Vec<_>>()[1];
        let msg = hex::decode(msg).unwrap();

        // # -of bytes to be skipped before message squeezing begins
        let q = reader.next().unwrap().unwrap();
        let q = q.split(" ").collect::<Vec<_>>()[1]
            .parse::<usize>()
            .unwrap();

        let out = reader.next().unwrap().unwrap();
        let out = out.split(" ").collect::<Vec<_>>()[1];

        // expected squeezed bytes
        let expected = hex::decode(out).unwrap();
        // to be squeezed bytes
        let mut computed = vec![0u8; expected.len()];

        let mut deck = Xoofff::new(&key);
        deck.absorb(&msg, 0, 0);
        deck.squeeze(&mut computed);

        assert_eq!(
            expected,
            computed,
            "key = {}, msg = {}, q = {}",
            hex::encode(&key),
            hex::encode(&msg),
            q
        );

        reader.next().unwrap().unwrap(); // skip the empty line
    }
}